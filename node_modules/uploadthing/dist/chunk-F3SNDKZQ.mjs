import {
  maybeParseResponseXML
} from "./chunk-5KWT532U.mjs";
import {
  incompatibleNodeGuard
} from "./chunk-WPSY3MFJ.mjs";
import {
  UPLOADTHING_VERSION,
  buildPermissionsInfoHandler,
  buildRequestHandler,
  createBuilder,
  formatError
} from "./chunk-BPTHKJTK.mjs";

// src/server.ts
import { getStatusCodeFromError, UploadThingError as UploadThingError3 } from "@uploadthing/shared";

// src/sdk/index.ts
import { generateUploadThingURL as generateUploadThingURL2, UploadThingError as UploadThingError2 } from "@uploadthing/shared";

// src/sdk/utils.ts
import {
  generateUploadThingURL,
  pollForFileData,
  UploadThingError
} from "@uploadthing/shared";
function guardServerOnly() {
  if (typeof window !== "undefined") {
    throw new UploadThingError({
      code: "INTERNAL_SERVER_ERROR",
      message: "The `utapi` can only be used on the server."
    });
  }
}
function getApiKeyOrThrow(apiKey) {
  if (apiKey)
    return apiKey;
  if (process.env.UPLOADTHING_SECRET)
    return process.env.UPLOADTHING_SECRET;
  throw new UploadThingError({
    code: "MISSING_ENV",
    message: "Missing `UPLOADTHING_SECRET` env variable."
  });
}
var uploadFilesInternal = async (data, opts) => {
  const fileData = data.files.map((file) => ({
    name: file.name ?? "unnamed-blob",
    type: file.type,
    size: file.size
  }));
  const res = await opts.fetch(generateUploadThingURL("/api/uploadFiles"), {
    method: "POST",
    headers: opts.utRequestHeaders,
    cache: "no-store",
    body: JSON.stringify({
      files: fileData,
      metadata: data.metadata,
      contentDisposition: data.contentDisposition
    })
  });
  if (!res.ok) {
    const error = await UploadThingError.fromResponse(res);
    throw error;
  }
  const clonedRes = res.clone();
  const json = await res.json();
  if ("error" in json) {
    const error = await UploadThingError.fromResponse(clonedRes);
    throw error;
  }
  const uploads = await Promise.allSettled(
    data.files.map(async (file, i) => {
      const { presignedUrl, fields, key, fileUrl } = json.data[i];
      if (!presignedUrl || !fields) {
        throw new UploadThingError({
          code: "URL_GENERATION_FAILED",
          message: "Failed to generate presigned URL",
          cause: JSON.stringify(json.data[i])
        });
      }
      const formData = new FormData();
      formData.append("Content-Type", file.type);
      Object.entries(fields).forEach(([key2, value]) => {
        formData.append(key2, value);
      });
      formData.append(
        "file",
        // Handles case when there is no file name
        file.name ? file : Object.assign(file, { name: "unnamed-blob" })
      );
      const s3res = await opts.fetch(presignedUrl, {
        method: "POST",
        body: formData,
        headers: new Headers({
          Accept: "application/xml"
        })
      });
      if (!s3res.ok) {
        await opts.fetch(generateUploadThingURL("/api/failureCallback"), {
          method: "POST",
          body: JSON.stringify({
            fileKey: fields.key
          }),
          headers: opts.utRequestHeaders
        });
        const text = await s3res.text();
        const parsed = maybeParseResponseXML(text);
        if (parsed == null ? void 0 : parsed.message) {
          throw new UploadThingError({
            code: "UPLOAD_FAILED",
            message: parsed.message
          });
        }
        throw new UploadThingError({
          code: "UPLOAD_FAILED",
          message: "Failed to upload file to storage provider",
          cause: s3res
        });
      }
      await pollForFileData(key);
      return {
        key,
        url: fileUrl,
        name: file.name,
        size: file.size
      };
    })
  );
  return uploads.map((upload) => {
    if (upload.status === "fulfilled") {
      const data2 = upload.value;
      return { data: data2, error: null };
    }
    const reason = upload.reason;
    const error = UploadThingError.toObject(reason);
    return { data: null, error };
  });
};

// src/sdk/index.ts
var UTApi = class {
  constructor(opts) {
    this.fetch = (opts == null ? void 0 : opts.fetch) ?? globalThis.fetch;
    this.apiKey = (opts == null ? void 0 : opts.apiKey) ?? process.env.UPLOADTHING_SECRET;
    this.defaultHeaders = {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": this.apiKey,
      "x-uploadthing-version": UPLOADTHING_VERSION
    };
  }
  async requestUploadThing(pathname, body, fallbackErrorMessage) {
    getApiKeyOrThrow();
    const res = await this.fetch(generateUploadThingURL2(pathname), {
      method: "POST",
      cache: "no-store",
      headers: this.defaultHeaders,
      body: JSON.stringify(body)
    });
    const json = await res.json();
    if (!res.ok || "error" in json) {
      console.error("[UT] Error:", json);
      throw new UploadThingError2({
        code: "INTERNAL_SERVER_ERROR",
        message: "error" in json && typeof json.error === "string" ? json.error : fallbackErrorMessage
      });
    }
    return json;
  }
  /**
   * @param {FileEsque | FileEsque[]} files The file(s) to upload
   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)
   *
   * @example
   * await uploadFiles(new File(["foo"], "foo.txt"));
   *
   * @example
   * await uploadFiles([
   *   new File(["foo"], "foo.txt"),
   *   new File(["bar"], "bar.txt"),
   * ]);
   */
  async uploadFiles(files, metadata = {}, contentDisposition = "inline") {
    guardServerOnly();
    incompatibleNodeGuard();
    const filesToUpload = Array.isArray(files) ? files : [files];
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata,
        contentDisposition
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
    return uploadFileResponse;
  }
  /**
   * @param {string} url The URL of the file to upload
   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)
   *
   * @example
   * await uploadFileFromUrl("https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await uploadFileFromUrl([
   *   "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
   *   "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"
   * ])
   */
  async uploadFilesFromUrl(urls, metadata = {}, contentDisposition = "inline") {
    guardServerOnly();
    const fileUrls = Array.isArray(urls) ? urls : [urls];
    const formData = new FormData();
    formData.append("metadata", JSON.stringify(metadata));
    const filesToUpload = await Promise.all(
      fileUrls.map(async (url) => {
        if (typeof url === "string")
          url = new URL(url);
        const filename = url.pathname.split("/").pop() ?? "unknown-filename";
        const fileResponse = await fetch(url);
        if (!fileResponse.ok) {
          throw new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Failed to download requested file.",
            cause: fileResponse
          });
        }
        const blob = await fileResponse.blob();
        return Object.assign(blob, { name: filename });
      })
    );
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata,
        contentDisposition
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];
    return uploadFileResponse;
  }
  /**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   */
  async deleteFiles(fileKeys) {
    guardServerOnly();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    return this.requestUploadThing(
      "/api/deleteFile",
      { fileKeys },
      "An unknown error occured while deleting files."
    );
  }
  /**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */
  async getFileUrls(fileKeys) {
    guardServerOnly();
    incompatibleNodeGuard();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    const json = await this.requestUploadThing(
      "/api/getFileUrl",
      { fileKeys },
      "An unknown error occured while retrieving file URLs."
    );
    return json.data;
  }
  /**
   * Request file list from UploadThing storage.
   *
   * @example
   * const data = await listFiles();
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */
  async listFiles() {
    guardServerOnly();
    incompatibleNodeGuard();
    const json = await this.requestUploadThing("/api/listFiles", {}, "An unknown error occured while listing files.");
    return json.files;
  }
  async renameFile(updates) {
    guardServerOnly();
    incompatibleNodeGuard();
    if (!Array.isArray(updates))
      updates = [updates];
    return this.requestUploadThing(
      "/api/renameFile",
      { updates },
      "An unknown error occured while renaming files."
    );
  }
  async getUsageInfo() {
    guardServerOnly();
    incompatibleNodeGuard();
    return this.requestUploadThing(
      "/api/getUsageInfo",
      {},
      "An unknown error occured while getting usage info."
    );
  }
};
var utapi = new UTApi();

// src/server.ts
var createUploadthing = (opts) => createBuilder(opts);
var createServerHandler = (opts) => {
  incompatibleNodeGuard();
  const requestHandler = buildRequestHandler(opts);
  const POST = async (request) => {
    const req = request instanceof Request ? request : request.request;
    const response = await requestHandler({ req });
    if (response instanceof UploadThingError3) {
      return new Response(JSON.stringify(formatError(response, opts.router)), {
        status: getStatusCodeFromError(response),
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    if (response.status !== 200) {
      return new Response("An unknown error occured", {
        status: 500,
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    return new Response(JSON.stringify(response.body), {
      status: response.status,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  const GET = (request) => {
    const _req = request instanceof Request ? request : request.request;
    return new Response(JSON.stringify(getBuildPerms()), {
      status: 200,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  return { GET, POST };
};
var extractRouterConfig = (router) => buildPermissionsInfoHandler({ router })();

export {
  UTApi,
  utapi,
  createUploadthing,
  createServerHandler,
  extractRouterConfig
};
//# sourceMappingURL=chunk-F3SNDKZQ.mjs.map