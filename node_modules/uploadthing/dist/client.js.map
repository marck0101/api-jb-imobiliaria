{"version":3,"sources":["../src/client.ts","../src/internal/s3-error-parser.ts","../src/internal/component-theming.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-argument */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport {\n  pollForFileData,\n  safeParseJSON,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { maybeParseResponseXML } from \"./internal/s3-error-parser\";\nimport type {\n  ActionType,\n  FileRouter,\n  inferEndpointInput,\n} from \"./internal/types\";\n\n/**\n * @internal\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */\nexport * from \"./internal/component-theming\";\n\nfunction fetchWithProgress(\n  url: string,\n  opts: {\n    headers?: Headers;\n    method?: string;\n    body?: string | FormData;\n  } = {},\n  onProgress?: (this: XMLHttpRequest, progress: ProgressEvent) => void,\n  onUploadBegin?: (this: XMLHttpRequest, progress: ProgressEvent) => void,\n) {\n  return new Promise<XMLHttpRequest>((res, rej) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(opts.method ?? \"get\", url);\n    opts.headers &&\n      Object.keys(opts.headers).forEach(\n        (h) =>\n          opts.headers && xhr.setRequestHeader(h, opts.headers.get(h) ?? \"\"),\n      );\n    xhr.onload = (e) => {\n      res(e.target as XMLHttpRequest);\n    };\n\n    xhr.onerror = rej;\n    if (xhr.upload && onProgress) xhr.upload.onprogress = onProgress;\n    if (xhr.upload && onUploadBegin) xhr.upload.onloadstart = onUploadBegin;\n    xhr.send(opts.body);\n  });\n}\n\nconst createAPIRequestUrl = (config: {\n  url?: string;\n  slug: string;\n  actionType: ActionType;\n}) => {\n  const url = new URL(\n    config.url ?? `${window.location.origin}/api/uploadthing`,\n  );\n\n  const queryParams = new URLSearchParams(url.search);\n  queryParams.set(\"actionType\", config.actionType);\n  queryParams.set(\"slug\", config.slug);\n\n  url.search = queryParams.toString();\n  return url.toString();\n};\n\ntype UploadFilesOptions<TRouter extends FileRouter> = {\n  [TEndpoint in keyof TRouter]: {\n    endpoint: TEndpoint;\n    onUploadProgress?: ({\n      file,\n      progress,\n    }: {\n      file: string;\n      progress: number;\n    }) => void;\n    onUploadBegin?: ({ file }: { file: string }) => void;\n    input?: inferEndpointInput<TRouter[TEndpoint]>;\n\n    files: File[];\n  };\n}[keyof TRouter];\n\nexport type UploadFileResponse = {\n  /**\n   * @deprecated\n   * use `name` instead\n   */\n  fileName: string;\n  name: string;\n  /**\n   * @deprecated\n   * use `size` instead\n   */\n  fileSize: number;\n  size: number;\n  /**\n   * @deprecated\n   * use `key` instead\n   */\n  fileKey: string;\n  key: string;\n  /**\n   * @deprecated\n   * use `url` instead\n   */\n  fileUrl: string;\n  url: string;\n};\n\nexport const DANGEROUS__uploadFiles = async <TRouter extends FileRouter>(\n  opts: UploadFilesOptions<TRouter>,\n  config?: {\n    url?: string;\n  },\n) => {\n  // Get presigned URL for S3 upload\n  const s3ConnectionRes = await fetch(\n    createAPIRequestUrl({\n      url: config?.url,\n      slug: String(opts.endpoint),\n      actionType: \"upload\",\n    }),\n    {\n      method: \"POST\",\n      body: JSON.stringify({\n        files: opts.files.map((f) => f.name),\n        input: opts.input,\n      }),\n      // Express requires Content-Type to be explicitly set to parse body properly\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    },\n  ).then(async (res) => {\n    // check for 200 response\n    if (!res.ok) {\n      const error = await UploadThingError.fromResponse(res);\n      throw error;\n    }\n\n    const jsonOrError = await safeParseJSON(res);\n    if (jsonOrError instanceof Error) {\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: jsonOrError.message,\n        cause: res,\n      });\n    }\n    return jsonOrError;\n  });\n\n  if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n    throw new UploadThingError({\n      code: \"BAD_REQUEST\",\n      message: \"No URL. How did you even get here?\",\n      cause: s3ConnectionRes,\n    });\n  }\n\n  const fileUploadPromises = s3ConnectionRes.map(async (presigned: any) => {\n    const file = opts.files.find((f) => f.name === presigned.name);\n\n    if (!file) {\n      console.error(\"No file found for presigned URL\", presigned);\n      throw new UploadThingError({\n        code: \"NOT_FOUND\",\n        message: \"No file found for presigned URL\",\n        cause: `Expected file with name ${\n          presigned.name\n        } but got '${opts.files.join(\",\")}'`,\n      });\n    }\n    const { url, fields } = presigned.presignedUrl;\n    const formData = new FormData();\n\n    // Give content type to blobs because S3 is dumb\n    // check if content-type is one of the allowed types, or if not and blobs are allowed, use application/octet-stream\n    if (\n      presigned.fileType === file.type.split(\"/\")[0] ||\n      presigned.fileType === file.type\n    ) {\n      formData.append(\"Content-Type\", file.type);\n    } else if (presigned.fileType === \"blob\") {\n      formData.append(\"Content-Type\", \"application/octet-stream\");\n    } else if (presigned.fileType === \"pdf\") {\n      formData.append(\"Content-Type\", \"application/pdf\");\n    }\n\n    // Dump all values from response (+ the file itself) into form for S3 upload\n    Object.entries({ ...fields, file: file }).forEach(([key, value]) => {\n      formData.append(key, value as Blob);\n    });\n\n    // Do S3 upload\n    const upload = await fetchWithProgress(\n      url,\n      {\n        method: \"POST\",\n        body: formData,\n        headers: new Headers({\n          Accept: \"application/xml\",\n        }),\n      },\n      (progressEvent) =>\n        opts.onUploadProgress?.({\n          file: file.name,\n          progress: (progressEvent.loaded / progressEvent.total) * 100,\n        }),\n      () => {\n        opts.onUploadBegin?.({\n          file: file.name,\n        });\n      },\n    );\n\n    if (upload.status > 299 || upload.status < 200) {\n      // tell uploadthing infra server that upload failed\n      await fetch(\n        createAPIRequestUrl({\n          url: config?.url,\n          slug: String(opts.endpoint),\n          actionType: \"failure\",\n        }),\n        {\n          method: \"POST\",\n          body: JSON.stringify({\n            fileKey: fields.key,\n          }),\n        },\n      );\n\n      // Attempt to parse response as XML\n      const parsed = maybeParseResponseXML(upload.responseText);\n\n      // Throw an error for the client\n      if (parsed?.message) {\n        throw new UploadThingError({\n          code: parsed.code,\n          message: parsed.message,\n        });\n      } else {\n        throw new UploadThingError({\n          code: \"UPLOAD_FAILED\",\n          message: `Failed to upload file ${file.name} to S3`,\n          cause: upload.responseText,\n        });\n      }\n    }\n\n    // Generate a URL for the uploaded image since AWS won't give me one\n    const genUrl = \"https://utfs.io/f/\" + encodeURIComponent(fields.key);\n\n    // Poll for file data, this way we know that the client-side onUploadComplete callback will be called after the server-side version\n    await pollForFileData(presigned.key);\n\n    // TODO: remove `file` prefix in next major version\n    const ret: UploadFileResponse = {\n      fileName: file.name,\n      name: file.name,\n      fileSize: file.size,\n      size: file.size,\n      fileKey: presigned.key,\n      key: presigned.key,\n      fileUrl: genUrl,\n      url: genUrl,\n    };\n    return ret;\n  });\n\n  return Promise.all(fileUploadPromises);\n};\n\nexport const genUploader = <\n  TRouter extends FileRouter,\n>(): typeof DANGEROUS__uploadFiles<TRouter> => {\n  return DANGEROUS__uploadFiles;\n};\n\nexport const classNames = (...classes: (string | boolean)[]) => {\n  return classes.filter(Boolean).join(\" \");\n};\n\nexport const generateMimeTypes = (fileTypes: string[]) => {\n  const accepted = fileTypes.map((type) => {\n    if (type === \"blob\") return \"blob\";\n    if (type === \"pdf\") return \"application/pdf\";\n    if (type.includes(\"/\")) return type;\n    else return `${type}/*`;\n  });\n\n  if (accepted.includes(\"blob\")) {\n    return undefined;\n  }\n  return accepted;\n};\n\nexport const generateClientDropzoneAccept = (fileTypes: string[]) => {\n  const mimeTypes = generateMimeTypes(fileTypes);\n\n  if (!mimeTypes) return undefined;\n\n  return Object.fromEntries(mimeTypes.map((type) => [type, []]));\n};\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nexport const maybeParseResponseXML = (maybeXml: string) => {\n  const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n  const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n\n  const code = codeMatch?.[1];\n  const message = messageMatch?.[1];\n\n  if (!code || !message) return null;\n\n  return { code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE, message };\n};\n\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */\nconst DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode: Record<string, UploadThingError[\"code\"]> = {\n  AccessDenied: \"FORBIDDEN\", // 403 Forbidden\n  EntityTooSmall: \"TOO_SMALL\", // 400 Bad Request\n  EntityTooLarge: \"TOO_LARGE\", // 400 Bad Request\n  ExpiredToken: \"FORBIDDEN\", // 400 Bad Request\n  IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\", // 400 Bad Request\n  InternalError: \"INTERNAL_SERVER_ERROR\", // 500 Internal Server Error\n  KeyTooLongError: \"KEY_TOO_LONG\", // 400 Bad Request\n  MaxMessageLengthExceeded: \"TOO_LARGE\", // 400 Bad Request\n};\n","import type { CSSProperties, ReactNode } from \"react\";\nimport type { JSX } from \"solid-js/jsx-runtime\";\n\nimport { objectKeys } from \"@uploadthing/shared\";\nimport type { ExpandedRouteConfig } from \"@uploadthing/shared\";\n\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */\n\nexport const generatePermittedFileTypes = (config?: ExpandedRouteConfig) => {\n  const fileTypes = config ? objectKeys(config) : [];\n\n  const maxFileCount = config\n    ? Object.values(config).map((v) => v.maxFileCount)\n    : [];\n\n  return { fileTypes, multiple: maxFileCount.some((v) => v && v > 1) };\n};\n\nexport const capitalizeStart = (str: string) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport const INTERNAL_doFormatting = (config?: ExpandedRouteConfig): string => {\n  if (!config) return \"\";\n\n  const allowedTypes = objectKeys(config);\n\n  const formattedTypes = allowedTypes.map((f) => (f === \"blob\" ? \"file\" : f));\n\n  // Format multi-type uploader label as \"Supports videos, images and files\";\n  if (formattedTypes.length > 1) {\n    const lastType = formattedTypes.pop();\n    return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n  }\n\n  // Single type uploader label\n  const key = allowedTypes[0];\n  const formattedKey = formattedTypes[0];\n\n  const { maxFileSize, maxFileCount } = config[key]!;\n\n  if (maxFileCount && maxFileCount > 1) {\n    return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n  } else {\n    return `${formattedKey} (${maxFileSize})`;\n  }\n};\n\nexport const allowedContentTextLabelGenerator = (\n  config?: ExpandedRouteConfig,\n): string => {\n  return capitalizeStart(INTERNAL_doFormatting(config));\n};\n\ntype AnyRuntime = \"react\" | \"solid\";\ntype MinCallbackArg = { __runtime: AnyRuntime };\ntype inferRuntime<T extends MinCallbackArg> = T[\"__runtime\"] extends \"react\"\n  ? \"react\"\n  : \"solid\";\n\ntype ElementEsque<TRuntime extends AnyRuntime> = TRuntime extends \"react\"\n  ? ReactNode\n  : JSX.Element;\ntype CSSPropertiesEsque<TRuntime extends AnyRuntime> = TRuntime extends \"react\"\n  ? CSSProperties\n  : JSX.CSSProperties;\n\nexport type StyleField<\n  CallbackArg extends MinCallbackArg,\n  TRuntime extends AnyRuntime = inferRuntime<CallbackArg>,\n> =\n  | string\n  | CSSPropertiesEsque<TRuntime>\n  | ((\n      arg: Omit<CallbackArg, \"__runtime\">,\n    ) => string | CSSPropertiesEsque<TRuntime>);\n\nexport type ContentField<\n  CallbackArg extends MinCallbackArg,\n  TRuntime extends AnyRuntime = inferRuntime<CallbackArg>,\n> =\n  | ElementEsque<TRuntime>\n  | ((arg: Omit<CallbackArg, \"__runtime\">) => ElementEsque<TRuntime>);\n\nexport const styleFieldToClassName = <T extends MinCallbackArg>(\n  styleField: StyleField<T> | undefined,\n  args: T,\n) => {\n  if (typeof styleField === \"string\") return styleField;\n  if (typeof styleField === \"function\") {\n    const result = styleField(args);\n\n    if (typeof result === \"string\") return result;\n  }\n\n  return \"\";\n};\n\nexport const styleFieldToCssObject = <T extends MinCallbackArg>(\n  styleField: StyleField<T> | undefined,\n  args: T,\n) => {\n  if (typeof styleField === \"object\") return styleField;\n  if (typeof styleField === \"function\") {\n    const result = styleField(args);\n\n    if (typeof result === \"object\") return result;\n  }\n\n  return {};\n};\n\nexport const contentFieldToContent = <T extends MinCallbackArg>(\n  contentField: ContentField<T> | undefined,\n  arg: T,\n) => {\n  if (!contentField) return null;\n  if (typeof contentField !== \"function\") return contentField;\n  if (typeof contentField === \"function\") {\n    const result = contentField(arg);\n\n    return result;\n  }\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,IAAAA,iBAIO;;;ACLA,IAAM,wBAAwB,CAAC,aAAqB;AACzD,QAAM,YAAY,SAAS,MAAM,sBAAsB;AACvD,QAAM,eAAe,SAAS,MAAM,4BAA4B;AAEhE,QAAM,OAAO,uCAAY;AACzB,QAAM,UAAU,6CAAe;AAE/B,MAAI,CAAC,QAAQ,CAAC;AAAS,WAAO;AAE9B,SAAO,EAAE,MAAM,wBAAwB,IAAI,KAAK,oBAAoB,QAAQ;AAC9E;AASA,IAAM,qBAAqB;AAC3B,IAAM,0BAAoE;AAAA,EACxE,cAAc;AAAA;AAAA,EACd,gBAAgB;AAAA;AAAA,EAChB,gBAAgB;AAAA;AAAA,EAChB,cAAc;AAAA;AAAA,EACd,qCAAqC;AAAA;AAAA,EACrC,eAAe;AAAA;AAAA,EACf,iBAAiB;AAAA;AAAA,EACjB,0BAA0B;AAAA;AAC5B;;;AC5BA,oBAA2B;AAOpB,IAAM,6BAA6B,CAAC,WAAiC;AAC1E,QAAM,YAAY,aAAS,0BAAW,MAAM,IAAI,CAAC;AAEjD,QAAM,eAAe,SACjB,OAAO,OAAO,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,YAAY,IAC/C,CAAC;AAEL,SAAO,EAAE,WAAW,UAAU,aAAa,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,EAAE;AACrE;AAEO,IAAM,kBAAkB,CAAC,QAAgB;AAC9C,SAAO,IAAI,OAAO,CAAC,EAAE,YAAY,IAAI,IAAI,MAAM,CAAC;AAClD;AAEO,IAAM,wBAAwB,CAAC,WAAyC;AAC7E,MAAI,CAAC;AAAQ,WAAO;AAEpB,QAAM,mBAAe,0BAAW,MAAM;AAEtC,QAAM,iBAAiB,aAAa,IAAI,CAAC,MAAO,MAAM,SAAS,SAAS,CAAE;AAG1E,MAAI,eAAe,SAAS,GAAG;AAC7B,UAAM,WAAW,eAAe,IAAI;AACpC,WAAO,GAAG,eAAe,KAAK,KAAK,SAAS;AAAA,EAC9C;AAGA,QAAM,MAAM,aAAa,CAAC;AAC1B,QAAM,eAAe,eAAe,CAAC;AAErC,QAAM,EAAE,aAAa,aAAa,IAAI,OAAO,GAAG;AAEhD,MAAI,gBAAgB,eAAe,GAAG;AACpC,WAAO,GAAG,uBAAuB,oBAAoB;AAAA,EACvD,OAAO;AACL,WAAO,GAAG,iBAAiB;AAAA,EAC7B;AACF;AAEO,IAAM,mCAAmC,CAC9C,WACW;AACX,SAAO,gBAAgB,sBAAsB,MAAM,CAAC;AACtD;AAgCO,IAAM,wBAAwB,CACnC,YACA,SACG;AACH,MAAI,OAAO,eAAe;AAAU,WAAO;AAC3C,MAAI,OAAO,eAAe,YAAY;AACpC,UAAM,SAAS,WAAW,IAAI;AAE9B,QAAI,OAAO,WAAW;AAAU,aAAO;AAAA,EACzC;AAEA,SAAO;AACT;AAEO,IAAM,wBAAwB,CACnC,YACA,SACG;AACH,MAAI,OAAO,eAAe;AAAU,WAAO;AAC3C,MAAI,OAAO,eAAe,YAAY;AACpC,UAAM,SAAS,WAAW,IAAI;AAE9B,QAAI,OAAO,WAAW;AAAU,aAAO;AAAA,EACzC;AAEA,SAAO,CAAC;AACV;AAEO,IAAM,wBAAwB,CACnC,cACA,QACG;AACH,MAAI,CAAC;AAAc,WAAO;AAC1B,MAAI,OAAO,iBAAiB;AAAY,WAAO;AAC/C,MAAI,OAAO,iBAAiB,YAAY;AACtC,UAAM,SAAS,aAAa,GAAG;AAE/B,WAAO;AAAA,EACT;AACF;;;AFvGA,SAAS,kBACP,KACA,OAII,CAAC,GACL,YACA,eACA;AACA,SAAO,IAAI,QAAwB,CAAC,KAAK,QAAQ;AAC/C,UAAM,MAAM,IAAI,eAAe;AAC/B,QAAI,KAAK,KAAK,UAAU,OAAO,GAAG;AAClC,SAAK,WACH,OAAO,KAAK,KAAK,OAAO,EAAE;AAAA,MACxB,CAAC,MACC,KAAK,WAAW,IAAI,iBAAiB,GAAG,KAAK,QAAQ,IAAI,CAAC,KAAK,EAAE;AAAA,IACrE;AACF,QAAI,SAAS,CAAC,MAAM;AAClB,UAAI,EAAE,MAAwB;AAAA,IAChC;AAEA,QAAI,UAAU;AACd,QAAI,IAAI,UAAU;AAAY,UAAI,OAAO,aAAa;AACtD,QAAI,IAAI,UAAU;AAAe,UAAI,OAAO,cAAc;AAC1D,QAAI,KAAK,KAAK,IAAI;AAAA,EACpB,CAAC;AACH;AAEA,IAAM,sBAAsB,CAAC,WAIvB;AACJ,QAAM,MAAM,IAAI;AAAA,IACd,OAAO,OAAO,GAAG,OAAO,SAAS;AAAA,EACnC;AAEA,QAAM,cAAc,IAAI,gBAAgB,IAAI,MAAM;AAClD,cAAY,IAAI,cAAc,OAAO,UAAU;AAC/C,cAAY,IAAI,QAAQ,OAAO,IAAI;AAEnC,MAAI,SAAS,YAAY,SAAS;AAClC,SAAO,IAAI,SAAS;AACtB;AA8CO,IAAM,yBAAyB,OACpC,MACA,WAGG;AAEH,QAAM,kBAAkB,MAAM;AAAA,IAC5B,oBAAoB;AAAA,MAClB,KAAK,iCAAQ;AAAA,MACb,MAAM,OAAO,KAAK,QAAQ;AAAA,MAC1B,YAAY;AAAA,IACd,CAAC;AAAA,IACD;AAAA,MACE,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU;AAAA,QACnB,OAAO,KAAK,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI;AAAA,QACnC,OAAO,KAAK;AAAA,MACd,CAAC;AAAA;AAAA,MAED,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,IACF;AAAA,EACF,EAAE,KAAK,OAAO,QAAQ;AAEpB,QAAI,CAAC,IAAI,IAAI;AACX,YAAM,QAAQ,MAAM,gCAAiB,aAAa,GAAG;AACrD,YAAM;AAAA,IACR;AAEA,UAAM,cAAc,UAAM,8BAAc,GAAG;AAC3C,QAAI,uBAAuB,OAAO;AAChC,YAAM,IAAI,gCAAiB;AAAA,QACzB,MAAM;AAAA,QACN,SAAS,YAAY;AAAA,QACrB,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT,CAAC;AAED,MAAI,CAAC,mBAAmB,CAAC,MAAM,QAAQ,eAAe,GAAG;AACvD,UAAM,IAAI,gCAAiB;AAAA,MACzB,MAAM;AAAA,MACN,SAAS;AAAA,MACT,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,QAAM,qBAAqB,gBAAgB,IAAI,OAAO,cAAmB;AACvE,UAAM,OAAO,KAAK,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU,IAAI;AAE7D,QAAI,CAAC,MAAM;AACT,cAAQ,MAAM,mCAAmC,SAAS;AAC1D,YAAM,IAAI,gCAAiB;AAAA,QACzB,MAAM;AAAA,QACN,SAAS;AAAA,QACT,OAAO,2BACL,UAAU,iBACC,KAAK,MAAM,KAAK,GAAG;AAAA,MAClC,CAAC;AAAA,IACH;AACA,UAAM,EAAE,KAAK,OAAO,IAAI,UAAU;AAClC,UAAM,WAAW,IAAI,SAAS;AAI9B,QACE,UAAU,aAAa,KAAK,KAAK,MAAM,GAAG,EAAE,CAAC,KAC7C,UAAU,aAAa,KAAK,MAC5B;AACA,eAAS,OAAO,gBAAgB,KAAK,IAAI;AAAA,IAC3C,WAAW,UAAU,aAAa,QAAQ;AACxC,eAAS,OAAO,gBAAgB,0BAA0B;AAAA,IAC5D,WAAW,UAAU,aAAa,OAAO;AACvC,eAAS,OAAO,gBAAgB,iBAAiB;AAAA,IACnD;AAGA,WAAO,QAAQ,EAAE,GAAG,QAAQ,KAAW,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAClE,eAAS,OAAO,KAAK,KAAa;AAAA,IACpC,CAAC;AAGD,UAAM,SAAS,MAAM;AAAA,MACnB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,MAAM;AAAA,QACN,SAAS,IAAI,QAAQ;AAAA,UACnB,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,MACA,CAAC,kBAAe;AA9MtB;AA+MQ,0BAAK,qBAAL,8BAAwB;AAAA,UACtB,MAAM,KAAK;AAAA,UACX,UAAW,cAAc,SAAS,cAAc,QAAS;AAAA,QAC3D;AAAA;AAAA,MACF,MAAM;AAnNZ;AAoNQ,mBAAK,kBAAL,8BAAqB;AAAA,UACnB,MAAM,KAAK;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAEA,QAAI,OAAO,SAAS,OAAO,OAAO,SAAS,KAAK;AAE9C,YAAM;AAAA,QACJ,oBAAoB;AAAA,UAClB,KAAK,iCAAQ;AAAA,UACb,MAAM,OAAO,KAAK,QAAQ;AAAA,UAC1B,YAAY;AAAA,QACd,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,MAAM,KAAK,UAAU;AAAA,YACnB,SAAS,OAAO;AAAA,UAClB,CAAC;AAAA,QACH;AAAA,MACF;AAGA,YAAM,SAAS,sBAAsB,OAAO,YAAY;AAGxD,UAAI,iCAAQ,SAAS;AACnB,cAAM,IAAI,gCAAiB;AAAA,UACzB,MAAM,OAAO;AAAA,UACb,SAAS,OAAO;AAAA,QAClB,CAAC;AAAA,MACH,OAAO;AACL,cAAM,IAAI,gCAAiB;AAAA,UACzB,MAAM;AAAA,UACN,SAAS,yBAAyB,KAAK;AAAA,UACvC,OAAO,OAAO;AAAA,QAChB,CAAC;AAAA,MACH;AAAA,IACF;AAGA,UAAM,SAAS,uBAAuB,mBAAmB,OAAO,GAAG;AAGnE,cAAM,gCAAgB,UAAU,GAAG;AAGnC,UAAM,MAA0B;AAAA,MAC9B,UAAU,KAAK;AAAA,MACf,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,MACf,MAAM,KAAK;AAAA,MACX,SAAS,UAAU;AAAA,MACnB,KAAK,UAAU;AAAA,MACf,SAAS;AAAA,MACT,KAAK;AAAA,IACP;AACA,WAAO;AAAA,EACT,CAAC;AAED,SAAO,QAAQ,IAAI,kBAAkB;AACvC;AAEO,IAAM,cAAc,MAEoB;AAC7C,SAAO;AACT;AAEO,IAAM,aAAa,IAAI,YAAkC;AAC9D,SAAO,QAAQ,OAAO,OAAO,EAAE,KAAK,GAAG;AACzC;AAEO,IAAM,oBAAoB,CAAC,cAAwB;AACxD,QAAM,WAAW,UAAU,IAAI,CAAC,SAAS;AACvC,QAAI,SAAS;AAAQ,aAAO;AAC5B,QAAI,SAAS;AAAO,aAAO;AAC3B,QAAI,KAAK,SAAS,GAAG;AAAG,aAAO;AAAA;AAC1B,aAAO,GAAG;AAAA,EACjB,CAAC;AAED,MAAI,SAAS,SAAS,MAAM,GAAG;AAC7B,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,IAAM,+BAA+B,CAAC,cAAwB;AACnE,QAAM,YAAY,kBAAkB,SAAS;AAE7C,MAAI,CAAC;AAAW,WAAO;AAEvB,SAAO,OAAO,YAAY,UAAU,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC/D;","names":["import_shared"]}