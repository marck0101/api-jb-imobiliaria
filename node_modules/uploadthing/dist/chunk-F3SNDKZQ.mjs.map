{"version":3,"sources":["../src/server.ts","../src/sdk/index.ts","../src/sdk/utils.ts"],"sourcesContent":["import { getStatusCodeFromError, UploadThingError } from \"@uploadthing/shared\";\nimport type { Json } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"./constants\";\nimport { formatError } from \"./internal/error-formatter\";\nimport type { RouterWithConfig } from \"./internal/handler\";\nimport {\n  buildPermissionsInfoHandler,\n  buildRequestHandler,\n} from \"./internal/handler\";\nimport { incompatibleNodeGuard } from \"./internal/incompat-node-guard\";\nimport type { FileRouter } from \"./internal/types\";\nimport type { CreateBuilderOptions } from \"./internal/upload-builder\";\nimport { createBuilder } from \"./internal/upload-builder\";\n\nexport * from \"./internal/types\";\nexport { utapi, UTApi } from \"./sdk\";\n\nexport const createUploadthing = <TErrorShape extends Json>(\n  opts?: CreateBuilderOptions<TErrorShape>,\n) =>\n  createBuilder<\n    { req: Request; res: undefined; event: undefined },\n    TErrorShape\n  >(opts);\n\nexport const createServerHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  incompatibleNodeGuard();\n\n  const requestHandler = buildRequestHandler<TRouter>(opts);\n\n  const POST = async (request: Request | { request: Request }) => {\n    const req = request instanceof Request ? request : request.request;\n    const response = await requestHandler({ req });\n\n    if (response instanceof UploadThingError) {\n      return new Response(JSON.stringify(formatError(response, opts.router)), {\n        status: getStatusCodeFromError(response),\n        headers: {\n          \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        },\n      });\n    }\n    if (response.status !== 200) {\n      // We messed up - this should never happen\n      return new Response(\"An unknown error occured\", {\n        status: 500,\n        headers: {\n          \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        },\n      });\n    }\n\n    return new Response(JSON.stringify(response.body), {\n      status: response.status,\n      headers: {\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      },\n    });\n  };\n\n  const getBuildPerms = buildPermissionsInfoHandler<TRouter>(opts);\n\n  const GET = (request: Request | { request: Request }) => {\n    const _req = request instanceof Request ? request : request.request;\n\n    return new Response(JSON.stringify(getBuildPerms()), {\n      status: 200,\n      headers: {\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      },\n    });\n  };\n\n  return { GET, POST };\n};\n\nexport const extractRouterConfig = (router: FileRouter) =>\n  buildPermissionsInfoHandler({ router })();\n","import type {\n  ContentDisposition,\n  FetchEsque,\n  Json,\n  MaybeUrl,\n} from \"@uploadthing/shared\";\nimport { generateUploadThingURL, UploadThingError } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { incompatibleNodeGuard } from \"../internal/incompat-node-guard\";\nimport type { FileEsque, UploadFileResponse } from \"./utils\";\nimport {\n  getApiKeyOrThrow,\n  guardServerOnly,\n  uploadFilesInternal,\n} from \"./utils\";\n\nexport interface UTApiOptions {\n  /**\n   * Provide a custom fetch function.\n   * @default globalThis.fetch\n   */\n  fetch?: FetchEsque;\n  /**\n   * Provide a custom UploadThing API key.\n   * @default process.env.UPLOADTHING_SECRET\n   */\n  apiKey?: string;\n}\n\nexport class UTApi {\n  private fetch: FetchEsque;\n  private apiKey: string | undefined;\n  private defaultHeaders: Record<string, string>;\n\n  constructor(opts?: UTApiOptions) {\n    this.fetch = opts?.fetch ?? globalThis.fetch;\n    this.apiKey = opts?.apiKey ?? process.env.UPLOADTHING_SECRET;\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      \"x-uploadthing-api-key\": this.apiKey!,\n      \"x-uploadthing-version\": UPLOADTHING_VERSION,\n    };\n  }\n\n  private async requestUploadThing<T extends Record<string, unknown>>(\n    pathname: `/${string}`,\n    body: Record<string, unknown>,\n    fallbackErrorMessage: string,\n  ) {\n    // Force API key to be set before requesting.\n    // Ideally we'd just throw in the constructor but since we need to export\n    // a `utapi` object we can't throw in the constructor because it would\n    // be a breaking change.\n    // FIXME: In next major\n    getApiKeyOrThrow();\n\n    const res = await this.fetch(generateUploadThingURL(pathname), {\n      method: \"POST\",\n      cache: \"no-store\",\n      headers: this.defaultHeaders,\n      body: JSON.stringify(body),\n    });\n\n    const json = await res.json<T | { error: string }>();\n    if (!res.ok || \"error\" in json) {\n      console.error(\"[UT] Error:\", json);\n      throw new UploadThingError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message:\n          \"error\" in json && typeof json.error === \"string\"\n            ? json.error\n            : fallbackErrorMessage,\n      });\n    }\n\n    return json;\n  }\n\n  /**\n   * @param {FileEsque | FileEsque[]} files The file(s) to upload\n   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)\n   *\n   * @example\n   * await uploadFiles(new File([\"foo\"], \"foo.txt\"));\n   *\n   * @example\n   * await uploadFiles([\n   *   new File([\"foo\"], \"foo.txt\"),\n   *   new File([\"bar\"], \"bar.txt\"),\n   * ]);\n   */\n  async uploadFiles<T extends FileEsque | FileEsque[]>(\n    files: T,\n    // FIXME: config option in v6 instead of positional args\n    metadata: Json = {},\n    contentDisposition: ContentDisposition = \"inline\",\n  ) {\n    guardServerOnly();\n    incompatibleNodeGuard();\n\n    const filesToUpload: FileEsque[] = Array.isArray(files) ? files : [files];\n\n    const uploads = await uploadFilesInternal(\n      {\n        files: filesToUpload,\n        metadata,\n        contentDisposition,\n      },\n      {\n        fetch: this.fetch,\n        utRequestHeaders: this.defaultHeaders,\n      },\n    );\n\n    const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];\n\n    return uploadFileResponse as T extends FileEsque[]\n      ? UploadFileResponse[]\n      : UploadFileResponse;\n  }\n\n  /**\n   * @param {string} url The URL of the file to upload\n   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)\n   *\n   * @example\n   * await uploadFileFromUrl(\"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await uploadFileFromUrl([\n   *   \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\n   *   \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"\n   * ])\n   */\n  async uploadFilesFromUrl<T extends MaybeUrl | MaybeUrl[]>(\n    urls: T,\n    // FIXME: config option in v6 instead of positional args\n    metadata: Json = {},\n    contentDisposition: ContentDisposition = \"inline\",\n  ) {\n    guardServerOnly();\n\n    const fileUrls: MaybeUrl[] = Array.isArray(urls) ? urls : [urls];\n\n    const formData = new FormData();\n    formData.append(\"metadata\", JSON.stringify(metadata));\n\n    const filesToUpload = await Promise.all(\n      fileUrls.map(async (url) => {\n        if (typeof url === \"string\") url = new URL(url);\n        const filename = url.pathname.split(\"/\").pop() ?? \"unknown-filename\";\n\n        // Download the file on the user's server to avoid egress charges\n        const fileResponse = await fetch(url);\n        if (!fileResponse.ok) {\n          throw new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Failed to download requested file.\",\n            cause: fileResponse,\n          });\n        }\n        const blob = await fileResponse.blob();\n        return Object.assign(blob, { name: filename });\n      }),\n    );\n\n    const uploads = await uploadFilesInternal(\n      {\n        files: filesToUpload,\n        metadata,\n        contentDisposition,\n      },\n      {\n        fetch: this.fetch,\n        utRequestHeaders: this.defaultHeaders,\n      },\n    );\n\n    const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];\n\n    return uploadFileResponse as T extends MaybeUrl[]\n      ? UploadFileResponse[]\n      : UploadFileResponse;\n  }\n\n  /**\n   * Request to delete files from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * await deleteFiles(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await deleteFiles([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   */\n  async deleteFiles(fileKeys: string[] | string) {\n    guardServerOnly();\n\n    if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n\n    return this.requestUploadThing<{ success: boolean }>(\n      \"/api/deleteFile\",\n      { fileKeys },\n      \"An unknown error occured while deleting files.\",\n    );\n  }\n\n  /**\n   * Request file URLs from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * const data = await getFileUrls(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   * console.log(data); // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\"}]\n   *\n   * @example\n   * const data = await getFileUrls([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   * console.log(data) // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\" },{key: \"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\", url: \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"}]\n   */\n  async getFileUrls(fileKeys: string[] | string) {\n    guardServerOnly();\n    incompatibleNodeGuard();\n\n    if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n\n    const json = await this.requestUploadThing<{\n      data: { key: string; url: string }[];\n    }>(\n      \"/api/getFileUrl\",\n      { fileKeys },\n      \"An unknown error occured while retrieving file URLs.\",\n    );\n\n    return json.data;\n  }\n\n  /**\n   * Request file list from UploadThing storage.\n   *\n   * @example\n   * const data = await listFiles();\n   * console.log(data); // { key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", id: \"2e0fdb64-9957-4262-8e45-f372ba903ac8\" }\n   */\n  async listFiles() {\n    guardServerOnly();\n    incompatibleNodeGuard();\n\n    // TODO: Implement filtering and pagination\n    const json = await this.requestUploadThing<{\n      files: {\n        key: string;\n        id: string;\n        status: \"Deletion Pending\" | \"Failed\" | \"Uploaded\" | \"Uploading\";\n      }[];\n    }>(\"/api/listFiles\", {}, \"An unknown error occured while listing files.\");\n\n    return json.files;\n  }\n\n  async renameFile(\n    updates:\n      | {\n          fileKey: string;\n          newName: string;\n        }\n      | {\n          fileKey: string;\n          newName: string;\n        }[],\n  ) {\n    guardServerOnly();\n    incompatibleNodeGuard();\n\n    if (!Array.isArray(updates)) updates = [updates];\n\n    return this.requestUploadThing<{ success: true }>(\n      \"/api/renameFile\",\n      { updates },\n      \"An unknown error occured while renaming files.\",\n    );\n  }\n\n  async getUsageInfo() {\n    guardServerOnly();\n    incompatibleNodeGuard();\n\n    return this.requestUploadThing<{\n      totalBytes: number;\n      totalReadable: string;\n      appTotalBytes: number;\n      appTotalReadable: string;\n      filesUploaded: number;\n      limitBytes: number;\n      limitReadable: string;\n    }>(\n      \"/api/getUsageInfo\",\n      {},\n      \"An unknown error occured while getting usage info.\",\n    );\n  }\n}\n\n/**\n * @deprecated\n *\n * Import `UTApi` and instantiate it yourself:\n * ```ts\n * import { UTApi } from \"@uploadthing/server\";\n * const utapi = new UTApi({ ... });\n * ```\n */\nexport const utapi = new UTApi();\n","import type { File as UndiciFile } from \"undici\";\n\nimport type { ContentDisposition, FetchEsque, Json } from \"@uploadthing/shared\";\nimport {\n  generateUploadThingURL,\n  pollForFileData,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { maybeParseResponseXML } from \"../internal/s3-error-parser\";\n\nexport function guardServerOnly() {\n  if (typeof window !== \"undefined\") {\n    throw new UploadThingError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"The `utapi` can only be used on the server.\",\n    });\n  }\n}\n\nexport function getApiKeyOrThrow(apiKey?: string) {\n  if (apiKey) return apiKey;\n  if (process.env.UPLOADTHING_SECRET) return process.env.UPLOADTHING_SECRET;\n\n  throw new UploadThingError({\n    code: \"MISSING_ENV\",\n    message: \"Missing `UPLOADTHING_SECRET` env variable.\",\n  });\n}\n\nexport type FileEsque = (Blob & { name: string }) | UndiciFile;\n\nexport type UploadData = {\n  key: string;\n  url: string;\n  name: string;\n  size: number;\n};\n\nexport type UploadError = {\n  code: string;\n  message: string;\n  data: any;\n};\n\nexport type UploadFileResponse =\n  | { data: UploadData; error: null }\n  | { data: null; error: UploadError };\n\nexport const uploadFilesInternal = async (\n  data: {\n    files: FileEsque[];\n    metadata: Json;\n    contentDisposition: ContentDisposition;\n  },\n  opts: {\n    fetch: FetchEsque;\n    utRequestHeaders: Record<string, string>;\n  },\n) => {\n  // Request presigned URLs for each file\n  const fileData = data.files.map((file) => ({\n    name: file.name ?? \"unnamed-blob\",\n    type: file.type,\n    size: file.size,\n  }));\n  const res = await opts.fetch(generateUploadThingURL(\"/api/uploadFiles\"), {\n    method: \"POST\",\n    headers: opts.utRequestHeaders,\n    cache: \"no-store\",\n    body: JSON.stringify({\n      files: fileData,\n      metadata: data.metadata,\n      contentDisposition: data.contentDisposition,\n    }),\n  });\n\n  if (!res.ok) {\n    const error = await UploadThingError.fromResponse(res as Response);\n    throw error;\n  }\n\n  const clonedRes = res.clone(); // so that `UploadThingError.fromResponse()` can consume the body again\n  const json = await res.json<\n    | {\n        data: {\n          presignedUrl: string; // url to post to\n          fields: Record<string, string>;\n          key: string;\n          fileUrl: string; // the final url of the file after upload\n        }[];\n      }\n    | { error: string }\n  >();\n\n  if (\"error\" in json) {\n    const error = await UploadThingError.fromResponse(clonedRes as Response);\n    throw error;\n  }\n\n  // Upload each file to S3\n  const uploads = await Promise.allSettled(\n    data.files.map(async (file, i) => {\n      const { presignedUrl, fields, key, fileUrl } = json.data[i];\n\n      if (!presignedUrl || !fields) {\n        throw new UploadThingError({\n          code: \"URL_GENERATION_FAILED\",\n          message: \"Failed to generate presigned URL\",\n          cause: JSON.stringify(json.data[i]),\n        });\n      }\n\n      const formData = new FormData();\n      formData.append(\"Content-Type\", file.type);\n      Object.entries(fields).forEach(([key, value]) => {\n        formData.append(key, value);\n      });\n\n      formData.append(\n        \"file\",\n        // Handles case when there is no file name\n        file.name\n          ? (file as File)\n          : Object.assign(file as File, { name: \"unnamed-blob\" }),\n      );\n\n      // Do S3 upload\n      const s3res = await opts.fetch(presignedUrl, {\n        method: \"POST\",\n        body: formData,\n        headers: new Headers({\n          Accept: \"application/xml\",\n        }),\n      });\n\n      if (!s3res.ok) {\n        // tell uploadthing infra server that upload failed\n        await opts.fetch(generateUploadThingURL(\"/api/failureCallback\"), {\n          method: \"POST\",\n          body: JSON.stringify({\n            fileKey: fields.key,\n          }),\n          headers: opts.utRequestHeaders,\n        });\n\n        const text = await s3res.text();\n        const parsed = maybeParseResponseXML(text);\n        if (parsed?.message) {\n          throw new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: parsed.message,\n          });\n        }\n        throw new UploadThingError({\n          code: \"UPLOAD_FAILED\",\n          message: \"Failed to upload file to storage provider\",\n          cause: s3res,\n        });\n      }\n\n      // Poll for file to be available\n      await pollForFileData(key);\n\n      return {\n        key,\n        url: fileUrl,\n        name: file.name,\n        size: file.size,\n      };\n    }),\n  );\n\n  return uploads.map((upload) => {\n    if (upload.status === \"fulfilled\") {\n      const data = upload.value satisfies UploadData;\n      return { data, error: null };\n    }\n    // We only throw UploadThingErrors, so this is safe\n    const reason = upload.reason as UploadThingError;\n    const error = UploadThingError.toObject(reason) satisfies UploadError;\n    return { data: null, error };\n  });\n};\n"],"mappings":";;;;;;;;;;;;;;;AAAA,SAAS,wBAAwB,oBAAAA,yBAAwB;;;ACMzD,SAAS,0BAAAC,yBAAwB,oBAAAC,yBAAwB;;;ACHzD;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIA,SAAS,kBAAkB;AAChC,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI,iBAAiB;AAAA,MACzB,MAAM;AAAA,MACN,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACF;AAEO,SAAS,iBAAiB,QAAiB;AAChD,MAAI;AAAQ,WAAO;AACnB,MAAI,QAAQ,IAAI;AAAoB,WAAO,QAAQ,IAAI;AAEvD,QAAM,IAAI,iBAAiB;AAAA,IACzB,MAAM;AAAA,IACN,SAAS;AAAA,EACX,CAAC;AACH;AAqBO,IAAM,sBAAsB,OACjC,MAKA,SAIG;AAEH,QAAM,WAAW,KAAK,MAAM,IAAI,CAAC,UAAU;AAAA,IACzC,MAAM,KAAK,QAAQ;AAAA,IACnB,MAAM,KAAK;AAAA,IACX,MAAM,KAAK;AAAA,EACb,EAAE;AACF,QAAM,MAAM,MAAM,KAAK,MAAM,uBAAuB,kBAAkB,GAAG;AAAA,IACvE,QAAQ;AAAA,IACR,SAAS,KAAK;AAAA,IACd,OAAO;AAAA,IACP,MAAM,KAAK,UAAU;AAAA,MACnB,OAAO;AAAA,MACP,UAAU,KAAK;AAAA,MACf,oBAAoB,KAAK;AAAA,IAC3B,CAAC;AAAA,EACH,CAAC;AAED,MAAI,CAAC,IAAI,IAAI;AACX,UAAM,QAAQ,MAAM,iBAAiB,aAAa,GAAe;AACjE,UAAM;AAAA,EACR;AAEA,QAAM,YAAY,IAAI,MAAM;AAC5B,QAAM,OAAO,MAAM,IAAI,KAUrB;AAEF,MAAI,WAAW,MAAM;AACnB,UAAM,QAAQ,MAAM,iBAAiB,aAAa,SAAqB;AACvE,UAAM;AAAA,EACR;AAGA,QAAM,UAAU,MAAM,QAAQ;AAAA,IAC5B,KAAK,MAAM,IAAI,OAAO,MAAM,MAAM;AAChC,YAAM,EAAE,cAAc,QAAQ,KAAK,QAAQ,IAAI,KAAK,KAAK,CAAC;AAE1D,UAAI,CAAC,gBAAgB,CAAC,QAAQ;AAC5B,cAAM,IAAI,iBAAiB;AAAA,UACzB,MAAM;AAAA,UACN,SAAS;AAAA,UACT,OAAO,KAAK,UAAU,KAAK,KAAK,CAAC,CAAC;AAAA,QACpC,CAAC;AAAA,MACH;AAEA,YAAM,WAAW,IAAI,SAAS;AAC9B,eAAS,OAAO,gBAAgB,KAAK,IAAI;AACzC,aAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAACC,MAAK,KAAK,MAAM;AAC/C,iBAAS,OAAOA,MAAK,KAAK;AAAA,MAC5B,CAAC;AAED,eAAS;AAAA,QACP;AAAA;AAAA,QAEA,KAAK,OACA,OACD,OAAO,OAAO,MAAc,EAAE,MAAM,eAAe,CAAC;AAAA,MAC1D;AAGA,YAAM,QAAQ,MAAM,KAAK,MAAM,cAAc;AAAA,QAC3C,QAAQ;AAAA,QACR,MAAM;AAAA,QACN,SAAS,IAAI,QAAQ;AAAA,UACnB,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,MAAM,IAAI;AAEb,cAAM,KAAK,MAAM,uBAAuB,sBAAsB,GAAG;AAAA,UAC/D,QAAQ;AAAA,UACR,MAAM,KAAK,UAAU;AAAA,YACnB,SAAS,OAAO;AAAA,UAClB,CAAC;AAAA,UACD,SAAS,KAAK;AAAA,QAChB,CAAC;AAED,cAAM,OAAO,MAAM,MAAM,KAAK;AAC9B,cAAM,SAAS,sBAAsB,IAAI;AACzC,YAAI,iCAAQ,SAAS;AACnB,gBAAM,IAAI,iBAAiB;AAAA,YACzB,MAAM;AAAA,YACN,SAAS,OAAO;AAAA,UAClB,CAAC;AAAA,QACH;AACA,cAAM,IAAI,iBAAiB;AAAA,UACzB,MAAM;AAAA,UACN,SAAS;AAAA,UACT,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAGA,YAAM,gBAAgB,GAAG;AAEzB,aAAO;AAAA,QACL;AAAA,QACA,KAAK;AAAA,QACL,MAAM,KAAK;AAAA,QACX,MAAM,KAAK;AAAA,MACb;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,QAAQ,IAAI,CAAC,WAAW;AAC7B,QAAI,OAAO,WAAW,aAAa;AACjC,YAAMC,QAAO,OAAO;AACpB,aAAO,EAAE,MAAAA,OAAM,OAAO,KAAK;AAAA,IAC7B;AAEA,UAAM,SAAS,OAAO;AACtB,UAAM,QAAQ,iBAAiB,SAAS,MAAM;AAC9C,WAAO,EAAE,MAAM,MAAM,MAAM;AAAA,EAC7B,CAAC;AACH;;;ADzJO,IAAM,QAAN,MAAY;AAAA,EAKjB,YAAY,MAAqB;AAC/B,SAAK,SAAQ,6BAAM,UAAS,WAAW;AACvC,SAAK,UAAS,6BAAM,WAAU,QAAQ,IAAI;AAC1C,SAAK,iBAAiB;AAAA,MACpB,gBAAgB;AAAA,MAChB,yBAAyB,KAAK;AAAA,MAC9B,yBAAyB;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,MAAc,mBACZ,UACA,MACA,sBACA;AAMA,qBAAiB;AAEjB,UAAM,MAAM,MAAM,KAAK,MAAMC,wBAAuB,QAAQ,GAAG;AAAA,MAC7D,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,SAAS,KAAK;AAAA,MACd,MAAM,KAAK,UAAU,IAAI;AAAA,IAC3B,CAAC;AAED,UAAM,OAAO,MAAM,IAAI,KAA4B;AACnD,QAAI,CAAC,IAAI,MAAM,WAAW,MAAM;AAC9B,cAAQ,MAAM,eAAe,IAAI;AACjC,YAAM,IAAIC,kBAAiB;AAAA,QACzB,MAAM;AAAA,QACN,SACE,WAAW,QAAQ,OAAO,KAAK,UAAU,WACrC,KAAK,QACL;AAAA,MACR,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAM,YACJ,OAEA,WAAiB,CAAC,GAClB,qBAAyC,UACzC;AACA,oBAAgB;AAChB,0BAAsB;AAEtB,UAAM,gBAA6B,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAExE,UAAM,UAAU,MAAM;AAAA,MACpB;AAAA,QACE,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,QACE,OAAO,KAAK;AAAA,QACZ,kBAAkB,KAAK;AAAA,MACzB;AAAA,IACF;AAEA,UAAM,qBAAqB,MAAM,QAAQ,KAAK,IAAI,UAAU,QAAQ,CAAC;AAErE,WAAO;AAAA,EAGT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAM,mBACJ,MAEA,WAAiB,CAAC,GAClB,qBAAyC,UACzC;AACA,oBAAgB;AAEhB,UAAM,WAAuB,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,IAAI;AAE/D,UAAM,WAAW,IAAI,SAAS;AAC9B,aAAS,OAAO,YAAY,KAAK,UAAU,QAAQ,CAAC;AAEpD,UAAM,gBAAgB,MAAM,QAAQ;AAAA,MAClC,SAAS,IAAI,OAAO,QAAQ;AAC1B,YAAI,OAAO,QAAQ;AAAU,gBAAM,IAAI,IAAI,GAAG;AAC9C,cAAM,WAAW,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI,KAAK;AAGlD,cAAM,eAAe,MAAM,MAAM,GAAG;AACpC,YAAI,CAAC,aAAa,IAAI;AACpB,gBAAM,IAAIA,kBAAiB;AAAA,YACzB,MAAM;AAAA,YACN,SAAS;AAAA,YACT,OAAO;AAAA,UACT,CAAC;AAAA,QACH;AACA,cAAM,OAAO,MAAM,aAAa,KAAK;AACrC,eAAO,OAAO,OAAO,MAAM,EAAE,MAAM,SAAS,CAAC;AAAA,MAC/C,CAAC;AAAA,IACH;AAEA,UAAM,UAAU,MAAM;AAAA,MACpB;AAAA,QACE,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,QACE,OAAO,KAAK;AAAA,QACZ,kBAAkB,KAAK;AAAA,MACzB;AAAA,IACF;AAEA,UAAM,qBAAqB,MAAM,QAAQ,IAAI,IAAI,UAAU,QAAQ,CAAC;AAEpE,WAAO;AAAA,EAGT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,YAAY,UAA6B;AAC7C,oBAAgB;AAEhB,QAAI,CAAC,MAAM,QAAQ,QAAQ;AAAG,iBAAW,CAAC,QAAQ;AAElD,WAAO,KAAK;AAAA,MACV;AAAA,MACA,EAAE,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,YAAY,UAA6B;AAC7C,oBAAgB;AAChB,0BAAsB;AAEtB,QAAI,CAAC,MAAM,QAAQ,QAAQ;AAAG,iBAAW,CAAC,QAAQ;AAElD,UAAM,OAAO,MAAM,KAAK;AAAA,MAGtB;AAAA,MACA,EAAE,SAAS;AAAA,MACX;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,YAAY;AAChB,oBAAgB;AAChB,0BAAsB;AAGtB,UAAM,OAAO,MAAM,KAAK,mBAMrB,kBAAkB,CAAC,GAAG,+CAA+C;AAExE,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,WACJ,SASA;AACA,oBAAgB;AAChB,0BAAsB;AAEtB,QAAI,CAAC,MAAM,QAAQ,OAAO;AAAG,gBAAU,CAAC,OAAO;AAE/C,WAAO,KAAK;AAAA,MACV;AAAA,MACA,EAAE,QAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,eAAe;AACnB,oBAAgB;AAChB,0BAAsB;AAEtB,WAAO,KAAK;AAAA,MASV;AAAA,MACA,CAAC;AAAA,MACD;AAAA,IACF;AAAA,EACF;AACF;AAWO,IAAM,QAAQ,IAAI,MAAM;;;ADtSxB,IAAM,oBAAoB,CAC/B,SAEA,cAGE,IAAI;AAED,IAAM,sBAAsB,CACjC,SACG;AACH,wBAAsB;AAEtB,QAAM,iBAAiB,oBAA6B,IAAI;AAExD,QAAM,OAAO,OAAO,YAA4C;AAC9D,UAAM,MAAM,mBAAmB,UAAU,UAAU,QAAQ;AAC3D,UAAM,WAAW,MAAM,eAAe,EAAE,IAAI,CAAC;AAE7C,QAAI,oBAAoBC,mBAAkB;AACxC,aAAO,IAAI,SAAS,KAAK,UAAU,YAAY,UAAU,KAAK,MAAM,CAAC,GAAG;AAAA,QACtE,QAAQ,uBAAuB,QAAQ;AAAA,QACvC,SAAS;AAAA,UACP,yBAAyB;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH;AACA,QAAI,SAAS,WAAW,KAAK;AAE3B,aAAO,IAAI,SAAS,4BAA4B;AAAA,QAC9C,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,yBAAyB;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO,IAAI,SAAS,KAAK,UAAU,SAAS,IAAI,GAAG;AAAA,MACjD,QAAQ,SAAS;AAAA,MACjB,SAAS;AAAA,QACP,yBAAyB;AAAA,MAC3B;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,gBAAgB,4BAAqC,IAAI;AAE/D,QAAM,MAAM,CAAC,YAA4C;AACvD,UAAM,OAAO,mBAAmB,UAAU,UAAU,QAAQ;AAE5D,WAAO,IAAI,SAAS,KAAK,UAAU,cAAc,CAAC,GAAG;AAAA,MACnD,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,yBAAyB;AAAA,MAC3B;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,EAAE,KAAK,KAAK;AACrB;AAEO,IAAM,sBAAsB,CAAC,WAClC,4BAA4B,EAAE,OAAO,CAAC,EAAE;","names":["UploadThingError","generateUploadThingURL","UploadThingError","key","data","generateUploadThingURL","UploadThingError","UploadThingError"]}